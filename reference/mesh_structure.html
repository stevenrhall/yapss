
<!DOCTYPE html>

<html class="writer-html5" data-content_root="../" lang="en">
<head>
<meta charset="utf-8"/><meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Mesh Structure — YAPSS 0.1.1.dev0</title>
<link href="../_static/pygments.css?v=77553476" rel="stylesheet" type="text/css"/>
<link href="../_static/css/theme.css?v=e59714d7" rel="stylesheet" type="text/css"/>
<link href="../_static/copybutton.css?v=76b2166b" rel="stylesheet" type="text/css"/>
<link href="../_static/css/custom.css" rel="stylesheet" type="text/css"/>
<script src="../_static/jquery.js?v=5d32c60e"></script>
<script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
<script src="../_static/documentation_options.js?v=091d38aa"></script>
<script src="../_static/doctools.js?v=9a2dae69"></script>
<script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
<script src="../_static/clipboard.min.js?v=a7894cd8"></script>
<script src="../_static/copybutton.js?v=35a8b989"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
<script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="../_static/js/theme.js"></script>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="ipopt_options.html" rel="next" title="Ipopt Options"/>
<link href="scaling.html" rel="prev" title="Scaling"/>
</head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../index.html">
            YAPSS
          </a>
<div role="search">
<form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div><div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/tutorial.html">Tutorial Example</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="problem.html">Problem Definition</a></li>
<li class="toctree-l1"><a class="reference internal" href="callbacks.html">Callback Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="bounds.html">Setting Bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="guess.html">Initial Guess</a></li>
<li class="toctree-l1"><a class="reference internal" href="derivatives.html">Derivatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_derivatives.html">User-Defined Derivatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="scaling.html">Scaling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mesh Structure</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#theory">Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-the-mesh-structure">Defining the Mesh Structure</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ipopt_options.html">Ipopt Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="solution.html">The Solution Object</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">Configuring the Ipopt Binary Source</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/index.html">JupyterLab Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scripts/index.html">Python Scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing to YAPSS</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="Mobile navigation menu" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../index.html">YAPSS</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="Page navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Home" class="icon icon-home" href="../index.html"></a></li>
<li class="breadcrumb-item active">Mesh Structure</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/stevenrhall/yapss/blob/main/docs/user_guide/reference/mesh_structure.rst"> Edit on GitHub</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<section id="mesh-structure">
<h1>Mesh Structure<a class="headerlink" href="#mesh-structure" title="Link to this heading"></a></h1>
<section id="theory">
<h2>Theory<a class="headerlink" href="#theory" title="Link to this heading"></a></h2>
<p>In pseudospectral optimal control methods, the state variable history over an interval is
approximated by a polynomial, defined by the value of the state at specific points in
time, the <em>interpolation</em> points. The state variable is then defined the the <em>Lagrange
interpolating polynomial</em>, which is the polynomial of minimal degree that passes through
the interpolation points. In addition, some of the interpolation points are also
<em>collocation</em> points, where the dynamics (and also) path constraints are enforced. In
addition, any integrands in the problem are evaluated at the collocation points, and
integrated using Gauss-Radau quadrature.</p>
<p>For example, for the Legendre-Gauss-Radau (LGR) pseudospectral method with <span class="math notranslate nohighlight">\(N\)</span>
collocation points over the interval <span class="math notranslate nohighlight">\([-1,1]\)</span>, the collocation points are defined as
the roots <span class="math notranslate nohighlight">\(t_i\)</span> of the equation</p>
<div class="math notranslate nohighlight">
\[P_N(t_i) +P_{N-1}(t_i) = 0,\quad i=0,1,\dots,N-1\]</div>
<p>where <span class="math notranslate nohighlight">\(P_N(x)\)</span> is the <span class="math notranslate nohighlight">\(N\text{th}\)</span> Legendre polynomial. All the collocation
points lie in the interval <span class="math notranslate nohighlight">\(t_i\in[-1,1)\)</span>. There is an additional interpolation
point at <span class="math notranslate nohighlight">\(t_N=1\)</span>.</p>
<p>Now consider the simplest example of solving an optimal control problem using the LGR
method, with a scalar state <span class="math notranslate nohighlight">\(x(t)\)</span> and scalar control <span class="math notranslate nohighlight">\(u(t)\)</span>, where the
problem is to optimize</p>
<div class="math notranslate nohighlight">
\[J = \int_{-1}^{1} g(x(t),u(t)) \, dt\]</div>
<p>subject to the dynamics</p>
<div class="math notranslate nohighlight">
\[\dot{x}(t) = f(x(t),u(t)),\quad x(-1) = x_0\]</div>
<p>The decision variables are the elements of the  <span class="math notranslate nohighlight">\(N+1\)</span>-dimensional state vector
<span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> and the <span class="math notranslate nohighlight">\(N\)</span>-dimensional control vector
<span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span>, where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{x}_i &amp;= x(t_i),\quad N=0,1,\dots,N \\
\boldsymbol{u}_i &amp;= u(t_i),\quad N=0,1,\dots,N-1\end{split}\]</div>
<p>Because the interpolating polymonial for <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> is unique, the time
derivative at each of the collocation points is also unique, and can be related to the
dynamics function <span class="math notranslate nohighlight">\(f\)</span> evaluated at the collocation points. If the dynamics function
values is represented by the vector <span class="math notranslate nohighlight">\(\boldsymbol{f}\)</span>, then the state dynamics
constraint becomes</p>
<div class="math notranslate nohighlight">
\[D \boldsymbol{x} = \boldsymbol{f(\boldsymbol{x},\boldsymbol{u})}\]</div>
<p>where <span class="math notranslate nohighlight">\(D\)</span> is the differentation matrix for the interpolating scheme. Further, the
integral is approximated by Gauss-Radau quadrature, so that the objective function becomes</p>
<div class="math notranslate nohighlight">
\[J = \sum_{i=0}^{N-1} w_i g(\boldsymbol{x}_i,\boldsymbol{u}_i)\]</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span> are the quadrature weights.</p>
<p>The Legendre-Gauss (LG), Legendre-Gauss-Radau (LGR), and Legendre-Gauss-Lobatto (LGL)
interpolation points give (in some sense) the most accurate approximations for the
integral and the dynamics constraint for a given number of collocation points. The methods
can be remarkably accurate for a modest number of points, especially for problems that are
sufficiently smooth. For many problem, the errors become exponentially small as the number of
collocation points increases.</p>
<p>However, for some problems the error converges to zero slowly with increasing number of
collocation points. This is often the case for problems with discontinuities due to path
constraints, but can occur for other reasons as well. For such problems, a better approach
is to use a segmented mesh, where each phase is divided into segments, and each segment
has LG, LGR, or LGL collocation points, each perhaps with a smaller number of collocation
points. YAPSS provides for such user-defined mesh structures.</p>
</section>
<section id="defining-the-mesh-structure">
<h2>Defining the Mesh Structure<a class="headerlink" href="#defining-the-mesh-structure" title="Link to this heading"></a></h2>
<p>The mesh structure is controlled by the <code class="docutils literal notranslate"><span class="pre">mesh</span></code> attribute of <code class="docutils literal notranslate"><span class="pre">Problem</span></code> instances. The
attributes that can be set are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mesh.phase[k].collocation_points</span></code> (Sequence[int]): Number of collocation points for
each segment of phase <code class="docutils literal notranslate"><span class="pre">k</span></code>. Each integer must be greater than or equal to 3. The
length of the sequence is the number segments in the phase.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mesh.phase[k].fraction</span></code> (Sequence[float]): The fraction of the phase duration of
each segment. Each element must be greater than 0.0 and less than 1.0, and the sum of
the elements must be close 1.0. The length of the <code class="docutils literal notranslate"><span class="pre">fraction</span></code> attribute  must be the
same as the length of the <code class="docutils literal notranslate"><span class="pre">collocation_points</span></code> attribute.</p></li>
</ul>
<p>The default mesh structure is 10 segments of equal duration duration, each with 10 collocation
points. That is, the default is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">problem</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">collocation_points</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="n">problem</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">fraction</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]</span>
</pre></div>
</div>
<p>Consider first the <a class="reference external" href="../notebooks/delta_iii_ascent.html">Delta III ascent problem</a> to minimize the
fuel require to reach a specific orbit. The vehicle has four stages, and hence the problems has
four phases. The default mesh results in a very large number of decision variables, and hence the
problem is slow to solve. We can speed up the solution by reducing the number of collocation points:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the mesh structure for the Delta III ascent problem</span>
<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>  <span class="c1"># 5 segments, each with 5 collocation points</span>
<span class="k">for</span> <span class="n">p_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">p_</span><span class="p">]</span><span class="o">.</span><span class="n">collocation_points</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">p_</span><span class="p">]</span><span class="o">.</span><span class="n">fraction</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="p">,)</span>
</pre></div>
</div>
<p>Or consider the <a class="reference external" href="../notebooks/dynamic_soaring.html">dynamic soaring problem</a>, where the objective
is to find the trajectory that allows a bird or glider to fly continuously using dynamics soaring,
with the minimum possible wind speed gradient. The solution is not smooth (it has discontinuous derivatives), because there is a
path constraint (on the maximum lift coefficient) that is active only for part of the soaring cycle.
To give a good solution even in the vicinity of the discontinuity, we can use a segmented mesh with
many segments:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the mesh structure for the dynamic soaring problem</span>
<span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">6</span>  <span class="c1"># 50 segments, each with 6 collocation points</span>
<span class="n">problem</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">collocation_points</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="p">,)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fraction</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="p">,)</span>
<span class="n">problem</span><span class="o">.</span><span class="n">spectral_method</span> <span class="o">=</span> <span class="s2">"lgl"</span>
</pre></div>
</div>
<p>It would be better to refine the mesh only in the vicinity of the discontinuities, but YAPSS does not
yet support automatic mesh refinement.</p>
</section>
</section>
</div>
</div>
<footer><div aria-label="Footer" class="rst-footer-buttons" role="navigation">
<a accesskey="p" class="btn btn-neutral float-left" href="scaling.html" rel="prev" title="Scaling"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
<a accesskey="n" class="btn btn-neutral float-right" href="ipopt_options.html" rel="next" title="Ipopt Options">Next <span aria-hidden="true" class="fa fa-arrow-circle-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<p>© Copyright 2021-2024 MIT.
      <span class="lastupdated">Last updated on Dec 29, 2024.
      </span></p>
</div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
</div>
</div>
</section>
</div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>